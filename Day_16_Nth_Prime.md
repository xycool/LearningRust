#  𝓝 Nth Prime

25년 1월 23일(목) 

https://exercism.org/tracks/rust/exercises/nth-prime

n번째 소수를 찾는 과제.

## 소수란?

- 1과 자신의 수를 약수로 가지는 1보다 큰 자연수다.
- 그러므로 2부터 시작한다.
- 2는 소수중에서 유일한 짝수값이다.

## 구현로직

- n이 100이라면 100번째 소수가 무엇인지 찾아야 하므로 벡터의 크기가 100이 될때까지 1씩 증가 순회한다.
- 해당수가 소수인지 판단하여 소수이면 벡터에 입력한다.
- 100번째 소수를 리턴한다.

## 소수 판단

### 약수의 성질 활용

-  어떤 수 `n`의 두 약수 `a`와 `b`가 있을 경우 a`와 `b`중 적어도 하나는 `n`의 제곱근보다 작거나 같다는 것이다.

- **12**의 약수는 1, 2, 3, 4, 6, 12.
	* 12 = 1 * 12
	* 12 = 2 * 6
	* 12 = 3 * 4 
	- 12의 제곱근은 약 3.46이다. 
	- 약수 쌍들을 보면, 각 쌍에서 적어도 하나의 수는 3.46보다 작거나 같다.

- **36**의 약수는 1, 2, 3, 4, 6, 9, 12, 18, 36.
    - 36 = 1 * 36
    - 36 = 2 * 18
    - 36 = 3 * 12
    - 36 = 4 * 9
    - 36 = 6 * 6 
    - 36의 제곱근은 6이다.  
    - 모든 약수 쌍에서 적어도 하나의 수는 6보다 작거나 같다.

이런 약수의 성질을 활용하면 어떤 수 `t`가 소수인지 확인하기 위해 1부터 `t`까지 모든 수로 나누어 볼 필요는 없다. 약수의 성질에 따라 `t`의 제곱근까지만 나누어 보아도 충분하다. 

만약 `t`가 소수가 아니라면, 약수 `a` 또는 `b` 중 적어도 하나는 `t`의 제곱근보다 작거나 같아야 한다. 따라서 `t`의 제곱근 이하의 어떤 수로 나누어 떨어지면 `t`는 소수가 아니고, 제곱근까지 어떤 수로도 나누어 떨어지지 않으면 `t`는 소수이다.

```rust
fn is_prime(t:u32) -> bool {
    if t <= 1 {return false;} // 1보다 큰 자연수가 소수
    if t == 2 {return true;} 
    if t % 2 == 0 {return false;} // 2로 나누어지면 소수 아님 (2는 제외)
    let sqrt_n = (t as f64).sqrt() as u32; // 제곱근
    let mut i:u32 = 3; 
    while i <= sqrt_n {
        if t % i == 0 {return false;}
        i += 2; // 홀수로만 검사해도 충분.
    }
    true
}

pub fn nth(n: u32) -> u32 {
    let mut v:Vec<u32> = Vec::new();
    let mut i = 2;// 소수 2부터 시작
    
    while (v.len() as u32) < n + 1 {
        if is_prime(i) {
            v.push(i)   
        }
        i += 1;
    }
    v[n as usize]   
}

fn main() {
	assert_eq!(nth(0), 2);
	assert_eq!(nth(1), 3);
	assert_eq!(nth(5), 13);
	assert_eq!(nth(10_000), 104_743);
}
```

### 개선

#### 커뮤니티 솔루션

커뮤니티 솔루션에 올라와 있는것 중에서 좋아요를 많이 받은 코드를 보고 내가 작성한 버전과 어떻게 다른지 확인해 봤다.

https://exercism.org/tracks/rust/exercises/nth-prime/solutions/parhamrm

```rust
fn is_prime(number: u32) -> bool 
{
	// 약수의 성질, 제곱근을 활용하고 any를 사용했다.
	// any는 하나라도 조건에 맞으면 true, 모두 false이면 false를 리턴한다.
	// 그러므로 모든 원소에 대해서 수행을 해야 한다.
	// 내 버전은 홀수로만 확인을 했다.
	// rust iterator를 활용한 멋진 코드다.
	!(2..(number as f32).sqrt() as u32 + 1).any(|x| number % x == 0)
}

pub fn nth(n: u32) -> u32 
{
	// rust의 filter, nth를 사용해서 아주 심플하게 while을 대체했다.
    (2..).filter(|x| is_prime(*x)).nth(n as usize).unwrap()
}
```


과제를 수행하는데는 충분한 해결책이지만 아주 큰 소수를 찾아야 할 경우 시간 복잡도가 엄청나게 증가할 것 같다.  좀 더 효율적으로 소수를 찾아내는 방법이 있는지 찾아봐야 겠다.














